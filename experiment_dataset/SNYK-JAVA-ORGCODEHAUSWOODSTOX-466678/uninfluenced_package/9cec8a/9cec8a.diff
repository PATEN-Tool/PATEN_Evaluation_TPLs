diff --git a/wstx/branches/4.1/src/java/com/ctc/wstx/api/ReaderConfig.java b/wstx/branches/4.1/src/java/com/ctc/wstx/api/ReaderConfig.java
index 9ab3236c..3dd90e0b 100644
--- a/wstx/branches/4.1/src/java/com/ctc/wstx/api/ReaderConfig.java
+++ b/wstx/branches/4.1/src/java/com/ctc/wstx/api/ReaderConfig.java
@@ -105,6 +105,13 @@ public final class ReaderConfig
     final static int PROP_BASE_URL = 57;
     final static int PROP_INPUT_PARSING_MODE = 58;
 
+    // Size limitation to prevent various DOS attacks
+    final static int PROP_MAX_ATTRIBUTES_PER_ELEMENT = 60;
+    final static int PROP_MAX_CHILDREN_PER_ELEMENT = 61;
+    final static int PROP_MAX_ELEMENT_COUNT = 62;
+    final static int PROP_MAX_ELEMENT_DEPTH = 63;
+    final static int PROP_MAX_CHARACTERS = 64;
+    
     /*
     ////////////////////////////////////////////////
     // Limits for numeric properties
@@ -291,6 +298,18 @@ public final class ReaderConfig
                         DataUtil.Integer(PROP_INPUT_BUFFER_LENGTH));
         sProperties.put(WstxInputProperties.P_MIN_TEXT_SEGMENT,
                         DataUtil.Integer(PROP_MIN_TEXT_SEGMENT));
+
+        sProperties.put(WstxInputProperties.P_MAX_ATTRIBUTES_PER_ELEMENT,
+                DataUtil.Integer(PROP_MAX_ATTRIBUTES_PER_ELEMENT));
+        sProperties.put(WstxInputProperties.P_MAX_CHILDREN_PER_ELEMENT,
+                DataUtil.Integer(PROP_MAX_CHILDREN_PER_ELEMENT));
+        sProperties.put(WstxInputProperties.P_MAX_ELEMENT_COUNT,
+                DataUtil.Integer(PROP_MAX_ELEMENT_COUNT));
+        sProperties.put(WstxInputProperties.P_MAX_ELEMENT_DEPTH,
+                DataUtil.Integer(PROP_MAX_ELEMENT_DEPTH));
+        sProperties.put(WstxInputProperties.P_MAX_CHARACTERS,
+                         DataUtil.Integer(PROP_MAX_CHARACTERS));
+
         sProperties.put(WstxInputProperties.P_CUSTOM_INTERNAL_ENTITIES,
                         DataUtil.Integer(PROP_CUSTOM_INTERNAL_ENTITIES));
         sProperties.put(WstxInputProperties.P_DTD_RESOLVER,
@@ -340,6 +359,11 @@ public final class ReaderConfig
 
     int mInputBufferLen;
     int mMinTextSegmentLen;
+    int mMaxAttributesPerElement = 1000;
+    int mMaxChildrenPerElement = Integer.MAX_VALUE;
+    int mMaxElementDepth = 1000;
+    long mMaxElementCount = Long.MAX_VALUE;
+    long mMaxCharacters = Long.MAX_VALUE;
 
     /**
      * Base URL to use as the resolution context for relative entity
@@ -436,6 +460,13 @@ private ReaderConfig(ReaderConfig base,
 
         mInputBufferLen = inputBufLen;
         mMinTextSegmentLen = minTextSegmentLen;
+        if (base != null) {
+            mMaxAttributesPerElement = base.mMaxAttributesPerElement;
+            mMaxChildrenPerElement = base.mMaxChildrenPerElement;
+            mMaxElementCount = base.mMaxElementCount;
+            mMaxElementDepth = base.mMaxElementDepth;
+            mMaxCharacters = base.mMaxCharacters;
+        }
 
         /* Ok, let's then see if we can find a buffer recycler. Since they
          * are lazily constructed, and since GC may just flush them out
@@ -489,6 +520,11 @@ public ReaderConfig createNonShared(SymbolTable sym)
         rc.mEntityResolver = mEntityResolver;
         rc.mBaseURL = mBaseURL;
         rc.mParsingMode = mParsingMode;
+        rc.mMaxAttributesPerElement = mMaxAttributesPerElement;
+        rc.mMaxChildrenPerElement = mMaxChildrenPerElement;
+        rc.mMaxElementCount = mMaxElementCount;
+        rc.mMaxCharacters = mMaxCharacters;
+        rc.mMaxElementDepth = mMaxElementDepth;
         if (mSpecialProperties != null) {
             int len = mSpecialProperties.length;
             Object[] specProps = new Object[len];
@@ -634,6 +670,13 @@ public boolean willTreatCharRefsAsEnts() {
 
     public int getShortestReportedTextSegment() { return mMinTextSegmentLen; }
 
+    public int getMaxAttributesPerElement() { return mMaxAttributesPerElement; }
+    public int getMaxChildrenPerElement() { return mMaxChildrenPerElement; }
+    public int getMaxElementDepth() { return mMaxElementDepth; }
+
+    public long getMaxElementCount() { return mMaxElementCount; }
+    public long getMaxCharacters() { return mMaxCharacters; }    
+
     public Map getCustomInternalEntities()
     {
         Map custEnt = (Map) _getSpecialProperty(SP_IX_CUSTOM_ENTITIES);
@@ -827,6 +870,21 @@ public void setInputBufferLength(int value)
         }
         mInputBufferLen = value;
     }
+    public void setMaxAttributesPerElement(int value) {
+        mMaxAttributesPerElement = value;
+    }
+    public void setMaxChildrenPerElement(int value) {
+        mMaxChildrenPerElement = value;
+    }
+    public void setMaxElementDepth(int value) {
+        mMaxElementDepth = value;
+    }
+    public void setMaxElementCount(long value) {
+        mMaxElementCount = value;
+    }
+    public void setMaxCharacters(long value) {
+        mMaxCharacters = value;
+    }
 
     public void setShortestReportedTextSegment(int value) {
         mMinTextSegmentLen = value;
@@ -1315,6 +1373,16 @@ public Object getProperty(int id)
             // then object values:
         case PROP_INPUT_BUFFER_LENGTH:
             return DataUtil.Integer(getInputBufferLength());
+        case PROP_MAX_ATTRIBUTES_PER_ELEMENT:
+            return DataUtil.Integer(getMaxAttributesPerElement());
+        case PROP_MAX_CHILDREN_PER_ELEMENT:
+            return DataUtil.Integer(getMaxChildrenPerElement());
+        case PROP_MAX_ELEMENT_DEPTH:
+            return DataUtil.Integer(getMaxElementDepth());
+        case PROP_MAX_ELEMENT_COUNT:
+            return DataUtil.Long(getMaxElementCount());
+        case PROP_MAX_CHARACTERS:
+            return DataUtil.Long(getMaxCharacters());
         case PROP_MIN_TEXT_SEGMENT:
             return DataUtil.Integer(getShortestReportedTextSegment());
         case PROP_CUSTOM_INTERNAL_ENTITIES:
@@ -1463,6 +1531,22 @@ public boolean setProperty(String propName, int id, Object value)
             setInputBufferLength(ArgUtil.convertToInt(propName, value, 1));
             break;
             
+        case PROP_MAX_ATTRIBUTES_PER_ELEMENT:
+            setMaxAttributesPerElement(ArgUtil.convertToInt(propName, value, 1));
+            break;
+        case PROP_MAX_CHILDREN_PER_ELEMENT:
+            setMaxChildrenPerElement(ArgUtil.convertToInt(propName, value, 1));
+            break;
+        case PROP_MAX_ELEMENT_DEPTH:
+            setMaxElementDepth(ArgUtil.convertToInt(propName, value, 1));
+            break;
+        case PROP_MAX_CHARACTERS:
+            setMaxCharacters(ArgUtil.convertToLong(propName, value, 1));
+            break;
+        case PROP_MAX_ELEMENT_COUNT:
+            setMaxElementCount(ArgUtil.convertToLong(propName, value, 1));
+            break;
+            
         case PROP_MIN_TEXT_SEGMENT:
             setShortestReportedTextSegment(ArgUtil.convertToInt(propName, value, 1));
             break;
diff --git a/wstx/branches/4.1/src/java/com/ctc/wstx/api/WstxInputProperties.java b/wstx/branches/4.1/src/java/com/ctc/wstx/api/WstxInputProperties.java
index 5b5d61cb..31ed3ac9 100644
--- a/wstx/branches/4.1/src/java/com/ctc/wstx/api/WstxInputProperties.java
+++ b/wstx/branches/4.1/src/java/com/ctc/wstx/api/WstxInputProperties.java
@@ -167,6 +167,14 @@ public final class WstxInputProperties
      * if not required to coalesce text.
      */
     public final static String P_MIN_TEXT_SEGMENT = "com.ctc.wstx.minTextSegment";
+    
+    // // // Other size constraints
+    public final static String P_MAX_ATTRIBUTES_PER_ELEMENT = "com.ctc.wstx.maxAttributesPerElement";
+    public final static String P_MAX_CHILDREN_PER_ELEMENT = "com.ctc.wstx.maxChildrenPerElement";
+    public final static String P_MAX_ELEMENT_COUNT = "com.ctc.wstx.maxElementCount";
+    public final static String P_MAX_ELEMENT_DEPTH = "com.ctc.wstx.maxElementDepth";
+    public final static String P_MAX_CHARACTERS = "com.ctc.wstx.maxCharacters";
+
 
     // // // Entity handling
 
diff --git a/wstx/branches/4.1/src/java/com/ctc/wstx/sr/AttributeCollector.java b/wstx/branches/4.1/src/java/com/ctc/wstx/sr/AttributeCollector.java
index 6a786f2a..788b7b97 100644
--- a/wstx/branches/4.1/src/java/com/ctc/wstx/sr/AttributeCollector.java
+++ b/wstx/branches/4.1/src/java/com/ctc/wstx/sr/AttributeCollector.java
@@ -190,6 +190,8 @@ public final class AttributeCollector
      * <code>mAttrMap</code> array.
      */
     protected int mAttrSpillEnd;
+    
+    protected int mMaxAttributesPerElement;
 
     /*
     ///////////////////////////////////////////////
@@ -207,6 +209,7 @@ protected AttributeCollector(ReaderConfig cfg, boolean nsAware)
             mXmlIdPrefix = null;
             mXmlIdLocalName = "xml:id";
         }
+        mMaxAttributesPerElement = cfg.getMaxAttributesPerElement();
     }
 
     /**
@@ -410,6 +413,14 @@ public String getValue(String nsURI, String localName)
         return null;
     }
 
+    public int getMaxAttributesPerElement() {
+        return mMaxAttributesPerElement;
+    }
+
+    public void setMaxAttributesPerElement(int maxAttributesPerElement) {
+        this.mMaxAttributesPerElement = maxAttributesPerElement;
+    }
+
     public int findIndex(String localName) {
         return findIndex(null, localName);
     }
@@ -736,7 +747,7 @@ protected void validateAttribute(int index, XMLValidator vld)
      * attributes. It returns the underlying 'raw' attribute value buffer
      * for direct access.
      */
-    public final TextBuilder getAttrBuilder(String attrPrefix, String attrLocalName)
+    public final TextBuilder getAttrBuilder(String attrPrefix, String attrLocalName) throws XMLStreamException
     {
         /* Ok: we have parsed prefixed-name of a regular
          * attribute. So let's initialize the instance...
@@ -749,6 +760,9 @@ public final TextBuilder getAttrBuilder(String attrPrefix, String attrLocalName)
         } else {
             int valueStart = mValueBuilder.getCharSize();
             if (mAttrCount >= mAttributes.length) {
+                if ((mAttrCount + mNsCount) >= mMaxAttributesPerElement) {
+                    throw new XMLStreamException("Attribute limit exceeded");
+                }
                 mAttributes = (Attribute[]) DataUtil.growArrayBy50Pct(mAttributes);
             }
             Attribute curr = mAttributes[mAttrCount];
@@ -781,7 +795,7 @@ public final TextBuilder getAttrBuilder(String attrPrefix, String attrLocalName)
      *    this was a duplicate
      */
     public int addDefaultAttribute(String localName, String uri, String prefix,
-                                   String value)
+                                   String value) throws XMLStreamException
     {
         int attrIndex = mAttrCount;
         if (attrIndex < 1) {
@@ -843,7 +857,7 @@ public final void setNormalizedValue(int index, String value)
      * @return null if the default namespace URI has been already declared
      *   for the current element; TextBuilder to add URI to if not.
      */
-    public TextBuilder getDefaultNsBuilder()
+    public TextBuilder getDefaultNsBuilder() throws XMLStreamException
     {
         if (mDefaultNsDeclared) {
             return null;
@@ -856,7 +870,7 @@ public TextBuilder getDefaultNsBuilder()
      * @return null if prefix has been already declared; TextBuilder to
      *   add value to if not.
      */
-    public TextBuilder getNsBuilder(String prefix)
+    public TextBuilder getNsBuilder(String prefix) throws XMLStreamException
     {
         // first: must verify that it's not a dup
         if (mNsCount == 0) {
@@ -878,6 +892,9 @@ public TextBuilder getNsBuilder(String prefix)
                 }
             }
             if (len >= mNamespaces.length) {
+                if ((mAttrCount + mNsCount) >= mMaxAttributesPerElement) {
+                    throw new XMLStreamException("Attribute limit exceeded");
+                }
                 mNamespaces = (Attribute[]) DataUtil.growArrayBy50Pct(mNamespaces);
             }
             int uriStart = mNamespaceBuilder.getCharSize();
diff --git a/wstx/branches/4.1/src/java/com/ctc/wstx/sr/BasicStreamReader.java b/wstx/branches/4.1/src/java/com/ctc/wstx/sr/BasicStreamReader.java
index d2ad69e5..1e90ecb3 100644
--- a/wstx/branches/4.1/src/java/com/ctc/wstx/sr/BasicStreamReader.java
+++ b/wstx/branches/4.1/src/java/com/ctc/wstx/sr/BasicStreamReader.java
@@ -1972,6 +1972,9 @@ private boolean nextFromProlog(boolean isProlog)
         } else {
             // Need to update the start location...
             mTokenInputTotal = mCurrInputProcessed + mInputPtr;
+            if (mTokenInputTotal > mConfig.getMaxCharacters()) {
+                throw new XMLStreamException("Character limit exceeded");
+            }
             mTokenInputRow = mCurrInputRow;
             mTokenInputCol = mInputPtr - mCurrInputRowStart;
             i = getNext();
@@ -2012,6 +2015,9 @@ private boolean nextFromProlog(boolean isProlog)
                  *   since it's non-WS, and thus non-lf/cr char)
                  */
                 mTokenInputTotal = mCurrInputProcessed + mInputPtr - 1;
+                if (mTokenInputTotal > mConfig.getMaxCharacters()) {
+                    throw new XMLStreamException("Character limit exceeded");
+                }
                 mTokenInputRow = mCurrInputRow;
                 mTokenInputCol = mInputPtr - mCurrInputRowStart - 1;
             }
@@ -2642,6 +2648,9 @@ private final int nextFromTree()
                  */
                 // First, need to update the start location...
                 mTokenInputTotal = mCurrInputProcessed + mInputPtr;
+                if (mTokenInputTotal > mConfig.getMaxCharacters()) {
+                    throw new XMLStreamException("Character limit exceeded");
+                }
                 mTokenInputRow = mCurrInputRow;
                 mTokenInputCol = mInputPtr - mCurrInputRowStart;
                 char c = (mInputPtr < mInputEnd) ? mInputBuffer[mInputPtr++]
@@ -2683,6 +2692,9 @@ && readCDataSecondary(mCfgLazyParsing
             }
             // Once again, need to update the start location info:
             mTokenInputTotal = mCurrInputProcessed + mInputPtr;
+            if (mTokenInputTotal > mConfig.getMaxCharacters()) {
+                throw new XMLStreamException("Character limit exceeded");
+            }
             mTokenInputRow = mCurrInputRow;
             mTokenInputCol = mInputPtr - mCurrInputRowStart;
             i = getNext();
@@ -3436,6 +3448,9 @@ private int skipToken()
         if (result < 1) {
             mTokenInputRow = mCurrInputRow;
             mTokenInputTotal = mCurrInputProcessed + mInputPtr;
+            if (mTokenInputTotal > mConfig.getMaxCharacters()) {
+                throw new XMLStreamException("Character limit exceeded");
+            }
             mTokenInputCol = mInputPtr - mCurrInputRowStart;
             return (result < 0) ? result : getNext();
         }
@@ -3443,6 +3458,9 @@ private int skipToken()
         // Ok, need to offset location, and return whatever we got:
         mTokenInputRow = mCurrInputRow;
         mTokenInputTotal = mCurrInputProcessed + mInputPtr - 1;
+        if (mTokenInputTotal > mConfig.getMaxCharacters()) {
+            throw new XMLStreamException("Character limit exceeded");
+        }
         mTokenInputCol = mInputPtr - mCurrInputRowStart - 1;
         return result;
     }
diff --git a/wstx/branches/4.1/src/java/com/ctc/wstx/sr/Element.java b/wstx/branches/4.1/src/java/com/ctc/wstx/sr/Element.java
index b1b2c898..96832b77 100644
--- a/wstx/branches/4.1/src/java/com/ctc/wstx/sr/Element.java
+++ b/wstx/branches/4.1/src/java/com/ctc/wstx/sr/Element.java
@@ -60,6 +60,11 @@ final class Element
      */
     protected Element mParent;
 
+    /**
+     * Count of child elements
+     */
+    protected int mChildCount;
+
     /*
     /////////////////////////////////////////////////////////
     // Life-cycle
@@ -80,6 +85,7 @@ public void reset(Element parent, int nsOffset, String prefix, String ln)
         mNsOffset = nsOffset;
         mPrefix = prefix;
         mLocalName = ln;
+        mChildCount = 0;
     }
 
     /**
diff --git a/wstx/branches/4.1/src/java/com/ctc/wstx/sr/InputElementStack.java b/wstx/branches/4.1/src/java/com/ctc/wstx/sr/InputElementStack.java
index 6430a36f..c5732cf6 100644
--- a/wstx/branches/4.1/src/java/com/ctc/wstx/sr/InputElementStack.java
+++ b/wstx/branches/4.1/src/java/com/ctc/wstx/sr/InputElementStack.java
@@ -86,6 +86,7 @@ public final class InputElementStack
     */
 
     protected int mDepth = 0;
+    protected long mTotalElements = 0;
 
     /**
      * Vector that contains all currently active namespaces; one String for
@@ -320,12 +321,26 @@ public BaseNsContext createNonTransientNsContext(Location loc)
      * Method called by the stream reader to add new (start) element
      * into the stack in namespace-aware mode; called when a start element
      * is encountered during parsing, but only in ns-aware mode.
+     * @throws XMLStreamException 
      */
-    public final void push(String prefix, String localName)
+    public final void push(String prefix, String localName) throws XMLStreamException
     {
         ++mDepth;
+        ++mTotalElements;
+        if (mDepth > mConfig.getMaxElementDepth()) {
+            throw new XMLStreamException("Maximum Element Depth Exceeded");
+        }
+        if (mTotalElements > mConfig.getMaxElementCount()) {
+            throw new XMLStreamException("Maximum Element Count Exceeded");
+        }
         String defaultNs = (mCurrElement == null) ?
             XmlConsts.DEFAULT_NAMESPACE_URI : mCurrElement.mDefaultNsURI;
+        if (mCurrElement != null) {
+            mCurrElement.mChildCount++;
+            if (mConfig.getMaxChildrenPerElement() > 0 && mCurrElement.mChildCount > mConfig.getMaxChildrenPerElement()) {
+                throw new XMLStreamException("Maximum Number of Children Elements Exceeded");
+            }
+        }
 
         if (mFreeElement == null) {
             mCurrElement = new Element(mCurrElement, mNamespaces.size(), prefix, localName);
@@ -828,7 +843,7 @@ public void reportProblem(XMLValidationProblem problem)
      * element.
      */
     public int addDefaultAttribute(String localName, String uri, String prefix,
-                                   String value)
+                                   String value) throws XMLStreamException
     {
         return mAttrCollector.addDefaultAttribute(localName, uri, prefix, value);
     }
diff --git a/wstx/branches/4.1/src/java/com/ctc/wstx/util/ArgUtil.java b/wstx/branches/4.1/src/java/com/ctc/wstx/util/ArgUtil.java
index 184e7f68..dc13dc70 100644
--- a/wstx/branches/4.1/src/java/com/ctc/wstx/util/ArgUtil.java
+++ b/wstx/branches/4.1/src/java/com/ctc/wstx/util/ArgUtil.java
@@ -48,6 +48,31 @@ public static int convertToInt(String prop, Object value, int minValue)
             throw new IllegalArgumentException("Invalid value type ("+value.getClass()+") for property '"+prop+"': expected Integer value.");
         }
 
+        if (i < minValue) {
+            throw new IllegalArgumentException("Invalid numeric value ("+i
+                                               +") for property '"+prop
+                                               +"': minimum is "+minValue+".");
+        }
+        return i;
+    }
+    public static long convertToLong(String prop, Object value, long minValue)
+    {
+        long i;
+
+        if (value == null) {
+            i = 0;
+        } else if (value instanceof Number) {
+            i = ((Number) value).longValue();
+        } else if (value instanceof String) {
+            try {
+                i = Long.parseLong((String) value);
+            } catch (NumberFormatException nex) {
+                throw new IllegalArgumentException("Invalid String value for property '"+prop+"': expected a number (Long).");
+            }
+        } else {
+            throw new IllegalArgumentException("Invalid value type ("+value.getClass()+") for property '"+prop+"': expected Long value.");
+        }
+
         if (i < minValue) {
             throw new IllegalArgumentException("Invalid numeric value ("+i
                                                +") for property '"+prop
diff --git a/wstx/branches/4.1/src/java/com/ctc/wstx/util/DataUtil.java b/wstx/branches/4.1/src/java/com/ctc/wstx/util/DataUtil.java
index 965567b1..b4b49d50 100644
--- a/wstx/branches/4.1/src/java/com/ctc/wstx/util/DataUtil.java
+++ b/wstx/branches/4.1/src/java/com/ctc/wstx/util/DataUtil.java
@@ -19,6 +19,7 @@ public final class DataUtil
             INTS[i] = new Integer(i);
         }
     }
+    final static Long MAX_LONG = new Long(Long.MAX_VALUE);
 
     private DataUtil() { }
 
@@ -42,7 +43,15 @@ public static Integer Integer(int i)
             return new Integer(i);
         }
         return INTS[i];
-    }    
+    }
+    
+    public static Long Long(long l)
+    {
+        if (l == Long.MAX_VALUE) {
+            return MAX_LONG;
+        }
+        return new Long(l);
+    }  
 
     /*
     ////////////////////////////////////////////////////////////
diff --git a/wstx/branches/4.1/src/java/org/codehaus/stax2/validation/ValidationContext.java b/wstx/branches/4.1/src/java/org/codehaus/stax2/validation/ValidationContext.java
index d43e93e9..c987ae94 100644
--- a/wstx/branches/4.1/src/java/org/codehaus/stax2/validation/ValidationContext.java
+++ b/wstx/branches/4.1/src/java/org/codehaus/stax2/validation/ValidationContext.java
@@ -184,7 +184,8 @@ public void reportProblem(XMLValidationProblem problem)
      *
      * @return Index of the newly added attribute, if operation was
      *    succesful; -1 if not.
+     * @throws XMLStreamException 
      */
     public int addDefaultAttribute(String localName, String uri, String prefix,
-                                   String value);
+                                   String value) throws XMLStreamException;
 }
diff --git a/wstx/branches/4.1/src/test/org/codehaus/stax/test/stream/TestAttributeRead.java b/wstx/branches/4.1/src/test/org/codehaus/stax/test/stream/TestAttributeRead.java
index aee79a00..55ced290 100644
--- a/wstx/branches/4.1/src/test/org/codehaus/stax/test/stream/TestAttributeRead.java
+++ b/wstx/branches/4.1/src/test/org/codehaus/stax/test/stream/TestAttributeRead.java
@@ -1,5 +1,9 @@
 package org.codehaus.stax.test.stream;
 
+import java.io.IOException;
+import java.io.Reader;
+import java.io.StringReader;
+
 import javax.xml.namespace.QName;
 import javax.xml.stream.*;
 
@@ -434,6 +438,41 @@ public void testInvalidAccessByIndex()
 
         sr.close();
     }
+    
+    public void testManyAttributes() throws Exception 
+    {
+        final int max = 100;
+        Reader reader = new Reader() {
+            StringReader sreader = new StringReader("<ns:element xmlns:ns=\"http://foo.com\"");
+            int count;
+            boolean done;
+            public int read(char[] cbuf, int off, int len) throws IOException {
+                int i = sreader.read(cbuf, off, len);
+                if (i == -1) {
+                    if (count < max) {
+                        sreader = new StringReader(" attribute" + count++ + "=\"foo\"");
+                    } else if (!done) {
+                        sreader = new StringReader("/>");
+                        done = true;
+                    }
+                    i = sreader.read(cbuf, off, len);
+                }
+                return i;
+            }
+            public void close() throws IOException {
+            }
+        };
+        try {
+            XMLInputFactory factory = getNewInputFactory();
+            factory.setProperty("com.ctc.wstx.maxAttributesPerElement", Integer.valueOf(max / 2));
+            XMLStreamReader xmlreader = factory.createXMLStreamReader(reader);
+            xmlreader.getProperty("com.ctc.wstx.maxAttributesPerElement");
+            xmlreader.nextTag();
+            fail("Should have failed");
+        } catch (XMLStreamException ex) {
+            //expected
+        }
+    }    
 
 
     /*
diff --git a/wstx/branches/4.1/src/test/org/codehaus/stax/test/stream/TestElements.java b/wstx/branches/4.1/src/test/org/codehaus/stax/test/stream/TestElements.java
index 026282e8..fa3a917d 100644
--- a/wstx/branches/4.1/src/test/org/codehaus/stax/test/stream/TestElements.java
+++ b/wstx/branches/4.1/src/test/org/codehaus/stax/test/stream/TestElements.java
@@ -1,8 +1,14 @@
 package org.codehaus.stax.test.stream;
 
+import java.io.IOException;
+import java.io.Reader;
+import java.io.StringReader;
+
 import javax.xml.namespace.*;
 import javax.xml.stream.*;
 
+import com.ctc.wstx.sr.BasicStreamReader;
+
 /**
  * Unit test suite that tests handling of XML elements, both in namespace
  * aware and non-namespace modes.
@@ -346,6 +352,144 @@ private void testInvalid(boolean nsAware, String method)
                              "more than one root element");
     }
 
+    
+    public void testSuperDeep() throws Exception 
+    {
+        final int max = Integer.MAX_VALUE;
+        Reader reader = new Reader() {
+            StringReader sreader = new StringReader("<ns:element xmlns:ns=\"http://foo.com\">");
+            int count;
+            boolean done;
+            public int read(char[] cbuf, int off, int len) throws IOException {
+                int i = sreader.read(cbuf, off, len);
+                if (i == -1) {
+                    if (count < max) {
+                        sreader = new StringReader("<ns:element>");
+                        count++;
+                    } else if (!done) {
+                        sreader = new StringReader("</ns:element>");
+                        done = true;
+                    }
+                    i = sreader.read(cbuf, off, len);
+                }
+                return i;
+            }
+            public void close() throws IOException {
+            }
+        };
+        try {
+            XMLInputFactory factory = getNewInputFactory();
+            factory.setProperty("com.ctc.wstx.maxElementDepth", Integer.valueOf(25));
+            XMLStreamReader xmlreader = factory.createXMLStreamReader(reader);
+            while (xmlreader.next() != XMLStreamReader.END_ELEMENT) {
+            }
+           
+            fail("Should have failed");
+        } catch (XMLStreamException ex) {
+            //expected
+        }
+    }      
+    public void testManyChildren() throws Exception 
+    {
+        final int max = Integer.MAX_VALUE;
+        Reader reader = new Reader() {
+            StringReader sreader = new StringReader("<ns:element xmlns:ns=\"http://foo.com\">");
+            int count;
+            boolean done;
+            public int read(char[] cbuf, int off, int len) throws IOException {
+                int i = sreader.read(cbuf, off, len);
+                if (i == -1) {
+                    if (count < max) {
+                        sreader = new StringReader("<ns:element/>");
+                        count++;
+                    } else if (!done) {
+                        sreader = new StringReader("</ns:element>");
+                        done = true;
+                    }
+                    i = sreader.read(cbuf, off, len);
+                }
+                return i;
+            }
+            public void close() throws IOException {
+            }
+        };
+        try {
+            XMLInputFactory factory = getNewInputFactory();
+            factory.setProperty("com.ctc.wstx.maxChildrenPerElement", Integer.valueOf(100));
+            XMLStreamReader xmlreader = factory.createXMLStreamReader(reader);
+            while (xmlreader.next() != XMLStreamReader.END_DOCUMENT) {
+            }
+            fail("Should have failed");
+        } catch (XMLStreamException ex) {
+            //expected
+        }
+    }  
+     
+    static Reader createManyElementReader() {
+        final int max = Integer.MAX_VALUE;
+        Reader reader = new Reader() {
+            StringReader sreader = new StringReader("<ns:element xmlns:ns=\"http://foo.com\"><ns:child0>");
+            int count;
+            int count2;
+            public int read(char[] cbuf, int off, int len) throws IOException {
+                int i = sreader.read(cbuf, off, len);
+                if (i == -1) {
+                    if ((count % 5000) == 1) {
+                        String close = "</ns:child" + count2 + ">";
+                        count2++;
+                        sreader = new StringReader(close + "<ns:child" + count2 + "><ns:element/>");
+                    } else if (count < max) {
+                        sreader = new StringReader("<ns:element/>");
+                        count++;
+                    }
+                    
+                    i = sreader.read(cbuf, off, len);
+                }
+                return i;
+            }
+            public void close() throws IOException {
+            }
+        };
+        return reader;
+    }
+    public void testManyElements() throws Exception 
+    {
+        
+        try {
+            XMLInputFactory factory = getNewInputFactory();
+            factory.setProperty("com.ctc.wstx.maxElementCount", Integer.valueOf(100));
+            XMLStreamReader xmlreader = factory.createXMLStreamReader(createManyElementReader());
+            while (xmlreader.next() != XMLStreamReader.END_DOCUMENT) {
+            }
+            fail("Should have failed");
+        } catch (XMLStreamException ex) {
+            //expected
+        }
+        try {
+            XMLInputFactory factory = getNewInputFactory();
+            XMLStreamReader xmlreader = factory.createXMLStreamReader(createManyElementReader());
+            ((BasicStreamReader)xmlreader).setProperty("com.ctc.wstx.maxElementCount", Integer.valueOf(100));
+            while (xmlreader.next() != XMLStreamReader.END_DOCUMENT) {
+            }
+            fail("Should have failed");
+        } catch (XMLStreamException ex) {
+            //expected
+        }
+    }
+    
+    public void testCharacterLimit() throws Exception {
+        try {
+            XMLInputFactory factory = getNewInputFactory();
+            factory.setProperty("com.ctc.wstx.maxCharacters", Integer.valueOf(100));
+            XMLStreamReader xmlreader = factory.createXMLStreamReader(createManyElementReader());
+            while (xmlreader.next() != XMLStreamReader.END_DOCUMENT) {
+            }
+            fail("Should have failed");
+        } catch (XMLStreamException ex) {
+            //expected
+        }        
+    }
+    
     /*
     ////////////////////////////////////////
     // Private methods, other